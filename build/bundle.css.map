{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../HomePage.svelte",
    "../../WidgetFetcher.svelte"
  ],
  "sourcesContent": [
    "<script>\n  import AddItem from \"./AddItem.svelte\";\n  import WidgetFetcher from \"../components/WidgetFetcher.svelte\";\n  import { getWidgets, removeWidget } from \"../helpers.js\";\n\n  let isEditModeActive = false;\n  let widgets = [];\n  update();\n\n  function update() {\n    widgets = getWidgets();\n  }\n  function remove(id) {\n    const result = confirm(\"Deleting widget, Are you sure?\");\n    if (result) {\n      removeWidget(id);\n      update();\n    }\n  }\n</script>\n\n<style>\n  .widget--delete {\n    position: absolute;\n    right: 2rem;\n    top: 1.5rem;\n  }\n</style>\n\n<div class=\"mx-sm\">\n  <div class=\"toolbar is-flex justify-space-between py-sm\">\n    <AddItem on:add={update} />\n    {#if widgets.length > 0}\n      <button\n        class=\"button is-link is-small ml-xs\"\n        on:click={() => {\n          isEditModeActive = !isEditModeActive;\n        }}>\n        Edit Widgets\n      </button>\n    {/if}\n  </div>\n\n  {#each widgets as widget (widget.id)}\n    <div class=\"card\">\n      <div class=\"card-content p-md\">\n        {#if widget.type === 'fetcher'}\n          <WidgetFetcher content={widget.content} />\n        {/if}\n        {#if isEditModeActive}\n          <button\n            class=\"delete widget--delete\"\n            aria-label=\"close\"\n            on:click={() => remove(widget.id)} />\n        {/if}\n      </div>\n    </div>\n  {/each}\n</div>\n",
    "<script>\n  import { getDataByPath, addNoCacheParam } from \"../helpers.js\";\n  import { isArray } from \"lodash-es\";\n  export let content;\n  let promise;\n  const corsProxyUrl = \"https://cors-anywhere.herokuapp.com/\";\n  init();\n\n  function init() {\n    promise = run(content);\n  }\n\n  async function run({\n    url,\n    config,\n    responseFormat,\n    noCache = false,\n    useProxy = false,\n    jsonPath = \"\"\n  }) {\n    const defaultConfig = {\n      method: \"GET\"\n    };\n\n    let parsedConfig;\n    try {\n      parsedConfig = JSON.parse(config);\n    } catch (error) {\n      parsedConfig = defaultConfig;\n    }\n    let newUrl = `${useProxy ? corsProxyUrl : \"\"}${url}`;\n    if (noCache) {\n      newUrl = addNoCacheParam(newUrl);\n    }\n\n    const res = await fetch(newUrl, parsedConfig);\n    let data = await res[responseFormat]();\n    data = responseFormat === \"json\" ? getDataByPath(data, jsonPath) : data;\n\n    if (res.ok) {\n      return data;\n    } else {\n      return \"failed to load\";\n    }\n  }\n\n  async function responseConvertor(value) {\n    window.value = value;\n    return await value;\n  }\n</script>\n\n<style>\n  .action {\n    cursor: pointer;\n  }\n  .widget--title {\n    font-size: 0.75rem;\n    color: #aaaaac;\n    font-weight: bold;\n  }\n</style>\n\n<div class=\"widget--content\">\n  <div class=\"widget--title mb-xs is-flex align-center\">\n    <span class=\"mr-sm\">{content.title || 'Untitled'}</span>\n    <div on:click={init} class=\"action\">\n      <ion-icon\n        class=\"has-text-info is-block\"\n        size=\"small\"\n        src=\"icons/reload-circle-sharp.svg\" />\n    </div>\n  </div>\n  {#await promise}\n    loading...\n  {:then value}\n    <div>\n      {#if isArray(value) && value.length === 1}\n        <span>{value}</span>\n      {:else if isArray(value)}\n        <table class=\"table is-bordered\">\n          <tr>\n            {#each value as colValue}\n              <td>{colValue}</td>\n            {/each}\n          </tr>\n        </table>\n      {:else}\n        <span>{value}</span>\n      {/if}\n    </div>\n  {/await}\n</div>\n"
  ],
  "names": [],
  "mappings": "AAsBE,eAAe,cAAC,CAAC,AACf,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,GAAG,CAAE,MAAM,AACb,CAAC;AC2BD,OAAO,cAAC,CAAC,AACP,MAAM,CAAE,OAAO,AACjB,CAAC,AACD,cAAc,cAAC,CAAC,AACd,SAAS,CAAE,OAAO,CAClB,KAAK,CAAE,OAAO,CACd,WAAW,CAAE,IAAI,AACnB,CAAC"
}